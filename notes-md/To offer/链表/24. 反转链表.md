力扣简单



定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 



示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

限制：0 <= 节点个数 <= 5000



迭代、头插法

时间复杂度 O(N) ： 遍历链表使用线性大小时间。
空间复杂度 O(1) ： 变量 pre 和 cur 使用常数大小额外空间。

````java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, pre = null;
        while(cur != null) {
            ListNode tmp = cur.next; // 暂存后继节点 cur.next
            cur.next = pre;          // 修改 next 引用指向
            pre = cur;               // pre 暂存 cur
            cur = tmp;               // cur 访问下一节点
        }
        return pre;
    }
}
````



递归

![1608689094615](F:/项目/Git-md/ZJW-Summary/assets/1608689094615.png)

时间复杂度 O(N) ： 遍历链表使用线性大小时间。
空间复杂度 O(N) ： 遍历链表的递归深度达到 N，系统使用 O(N) 大小额外空间。

````java
class Solution {
    public ListNode reverseList(ListNode head) {
        return recur(head, null);    // 调用递归并返回
    }
    private ListNode recur(ListNode cur, ListNode pre) {
        if (cur == null) return pre; // 终止条件
        ListNode res = recur(cur.next, cur);  // 递归后继节点
        cur.next = pre;              // 修改节点引用指向
        return res;                  // 返回反转链表的头节点
    }
}
````
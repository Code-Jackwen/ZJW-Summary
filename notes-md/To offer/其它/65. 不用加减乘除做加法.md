力扣简单



写一个函数，求两个整数之和，两数字均可能是负数或 0，且结果不会溢出 32 位整数，且要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

 

示例:

输入: a = 1, b = 1
输出: 2







考查位运算对 +、- 的表示。



例子：

> 十进制，遇到大于等于10就保留余数，然后进位1。
> 二进制，遇到2就保留余数，然后进位1。



十进制计算 13 + 9 = 22 ，转换为计算二进制 1101+1001：

1.计算不进位的和。

从左到右，第1位为0，第2位为1，第3位为0，第4位为0，结果为0100；



2.计算进位。

从左到右，第1位进位1，第2、3位没有进位，第4位进位1，进位右边要补0，正确结果是10010。



此时重复计算以上两二进制结果 0100+10010：

1.计算不进位的和：10110；
2.计算进位：没有进位。		此时没有了进位，那么10110 就是最终结果。



位运算转化：

1.计算不进位的和。等价于计算 a ^ b

2.计算进位。等价于计算 (a & b) << 1

因此要再重复上述过程，当其中的((a&b)<<1)变为 0 后就是终止条件，此时的(a^b)就是最终结果。



规律与结论：

计算 a + b，等价于 (a^b) + ((a&b)<<1) 。



时间复杂度 O(1) ： int类型，最差情况下（例如 a =a= 0x7fffffff , b = 1b=1 时），需循环 32 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1)时间。

空间复杂度 O(1) ： 使用常数大小的额外空间。

````java
public int add(int a, int b) {
        while (b != 0) {
            int plus = a ^ b; // 计算不进位的和
            b = (a & b) << 1; // 计算进位
            a = plus;//刷新a的值
        }
        return a;
}
````

补充：

在计算机系统中，数值一律用 **补码** 来表示和存储。CPU只有加法器，而补码的优势是，加法、减法可以统一处理。因此，以上方法 **同时适用于正数和负数的加法** 。 

Python，Java 等语言中的数字都是以 **补码** 形式存储的。但 Python 没有 `int` , `long` 等不同长度变量，即在编程时无变量位数的概念。 具体详查。

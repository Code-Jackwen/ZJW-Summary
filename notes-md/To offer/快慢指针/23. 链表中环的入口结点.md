牛客中等



属于快慢指针



给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 

要求不能使用额外的空间。





![1608645129213](F:/项目/Git-md/ZJW-Summary/assets/1608645129213.png)

俩结论

结论一：设置快慢指针，假如有环，他们最后一定相遇。
结论二：两个指针分别从链表头和相遇点继续出发，每次走1步，最后一定相遇与环入口。



结论二证明：

相遇时，快指针路程 = a+(b+c)k+b	 ，k>=1 

相遇时，慢指针路程= a+b 

假设快指针走的路程是慢指针的两倍，(a+b)2 = a+(b+c)k+b 

化简可得：a = (k-1)(b+c)+c  链表头到环入口的距离=相遇点到环入口的距离 +（k-1）圈环长度。 



时间复杂度：O(n)

空间复杂度：O(1)

```java
public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        ListNode fast=pHead;
        ListNode slow=pHead;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                break;
        }
        //这里判断 链表是否存在环。
        if(fast==null||fast.next==null)
            return null;
        slow=pHead;
        while(fast!=slow){
            fast=fast.next;
            slow=slow.next;
        }
        return slow;
    }
}
```

另一种写法思路：
先计算出 环有几个节点（比如说N），让A指针从头开始走N次，停下。走个b+c
再让B指针和A指针一起开始走，最终相遇入口点。

A：b+c + a	也就是说让A提前 多走一个环，再次回头和B相遇
B：a  

````java
public class Solution {
	public ListNode EntryNodeOfLoop(ListNode pHead) {
        //找到相遇点
		ListNode meetingNode=meetingNode(pHead);
        //这里判断 链表是否存在环。
		if(meetingNode==null||meetingNode.next==null)
			return null;
        
		//得到环中的节点个数
		int cntInLoop=1;
		ListNode p1=meetingNode;
		while(p1.next!=meetingNode){
			p1=p1.next;
			++cntInLoop;
		}
		//移动p1
		p1=pHead;
		for(int i=0;i<cntInLoop;i++){
			p1=p1.next;
		}
		//移动p1，p2
		ListNode p2=pHead;
		while(p1!=p2){
			p1=p1.next;
			p2=p2.next;
		}
		return p1;
	}
    
    //快指针走2步，慢指针走1步，最终相遇在环内。
	public static ListNode meetingNode(ListNode head) {
		if(head==null)
			return null;
        
        ListNode fast=pHead;
        ListNode slow=pHead;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                break;
        }
        return fast;
    }
}
````




力扣简单



在字符串 s 中找出**第一个**只出现一次的字符。如果没有，返回一个单空格。 **s 只包含小写字母**。



示例：

s = "abaccdeff"
返回 "b"

s = "" 
返回 " "



0 <= s 的长度 <= 50000




思路：

最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。 

考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用**两个比特位**就能存储这些信息。



BitSet版本：（推荐）或者说布尔数组版本，相比int 类型数组，4\*8 ：2\*2 缩小8倍左右。



时间复杂度：O(2N)=O(N)
空间复杂度：O(256)=O(1)

````java
public int FirstNotRepeatingChar2(String str) {
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) && !bs2.get(c))
            bs1.set(c);     // 0 0 -> 0 1 全部的
        else if (bs1.get(c) && !bs2.get(c))
            bs2.set(c);     // 0 1 -> 1 1	超过1次的。
    }
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) && !bs2.get(c))
            return i;
    }
    return -1;
}
````



整型数组版本：


考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。

````java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
````



HashMap版本：（不推荐）

HashMap<Character, Boolean>解法：对每个字符存布尔值、大于1次的都修改为false ，值设置为布尔类型减小空间。



时间复杂度 O(N) ： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) 。HashMap 查找操作的复杂度为 O(1) 。
空间复杂度 O(1) ： 由于题目指出 s 只包含小写字母，HashMap 存储需占用最多 O(26) = O(1) 的额外空间。

````java
class Solution {
    public char firstUniqChar(String s) {
        HashMap<Character, Boolean> dic = new HashMap<>();
        char[] sc = s.toCharArray();
        for(char c : sc)
            dic.put(c, !dic.containsKey(c));//包含存false，不包含存true
        for(char c : sc)
            if(dic.get(c)) return c;
        return ' ';
    }
}
````

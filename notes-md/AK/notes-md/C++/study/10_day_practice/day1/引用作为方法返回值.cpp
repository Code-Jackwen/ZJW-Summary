#include <iostream>
using namespace std;

//使用引用来替代指针，会使 C++ 程序更容易阅读和维护。
//C++ 函数可以返回一个引用，方式与返回一个指针类似。
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};

double& setValues(int i) {
	double& ref = vals[i];
	return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]，最后再返回 shit。
}


// 要调用上面定义函数的主函数
int main () {
	cout << "改变前的值" << endl;
	for ( int i = 0; i < 5; i++ ) {
		cout << "vals[" << i << "] = ";
		cout << vals[i] << endl;
	}

	//当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。
	setValues(1) = 20.231; 	// 改变第 2 个元素
	setValues(3) = 70.811;   // 改变第 4 个元素

	cout << "改变后的值" << endl;
	for ( int i = 0; i < 5; i++ ) {
		cout << "vals[" << i << "] = ";
		cout << vals[i] << endl;
	}

	//当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的.
	//但是，可以返回一个对静态变量的引用。
//	int& func() {
//		int q;
//		//! return q; // 在编译时发生错误
//		static int x;
//		return x;     // 安全，x 在函数作用域外依然是有效的
//	}


//（1）以引用返回函数值，定义函数时需要在函数名前加 &
//（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

//引用作为返回值，必须遵守以下规则：
//（1）不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，
//因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。

// （2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，
//可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。
//例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，
//那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。

// （3）可以返回类成员的引用，但最好是const。
//主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，
//因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），
//那么对该属性的单纯赋值就会破坏业务规则的完整性。

	return 0;
}



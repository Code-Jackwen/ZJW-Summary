力扣中等



判断整数数组数组是不是某二叉搜索树的**后序遍历**结果。如果是则返回 true，否则返回 false。数组数字不重复。

 

参考以下这颗二叉搜索树：

 	5
	/ \

   2   6
  / \
 1   3



示例 1：

输入: \[1，6，3，2，5]
输出: false

示例 2：

输入: \[1，3，2，6，5]
输出: true




提示：

数组长度 <= 1000





##### 方法一：递归

思路：

根据二叉搜索树的定义，根节点左边都小于跟节点，根节点右边都大于根节点。题目中也不包含重复的，因此不考虑等于的情况。

实现上就是对数组进行遍历、划分左右子树区间、递归再次校验，看是否所有子树都满足二叉搜索树的定义。



例子： \[1，3，2，6，5]

i、j、m 对 数组进行划分，划分出左、右子树再进行判断、递归。下边索引二字多余。

m 缓存每一层从左到右的第一个大于根节点的节点的索引，第一层就是 6 的索引。

i 代表子树的最左边的索引，第一层代表 1 的索引，j 代表根节点索引，第一层就是5的索引。



判断的条件：

左子树区间 \[i， m - 1] ：

所有节点都应 < 根节点 postorder\[j]  。而划分左右子树是从左到右找第一个大于根节点的节点的索引，因此已经保证左子树区间的正确性，因此只需要判断右子树区间都大于根节点即可，题目说没有重复节点所以不考虑等于。

右子树区间 \[m， j - 1] ：

所有节点都应 > 根节点 postorder\[j]  。实现方式为遍历，当遇到 postorder\[j] ≤ postorder\[j] 的节点的情况反回false ，具体是通过判断 p == j 。p 是临时遍历子树的索引指针，如果子树没问题那么最终p应该和 j 相等。

 

时间复杂度 O(N*N) ： 

最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。

又每次调用 recur(i，j) 减去一个根节点，即在递归中又遍历，因此递归占用 O(N) 。

空间复杂度 O(N) ： 

最差情况下（即当树退化为链表），递归深度将达到 N 。

````java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return recur(postorder, 0, postorder.length - 1);
    }
    boolean recur(int[] postorder, int i, int j) {
        //终止：说明此子树节点数量 ≤1 拆分到头了，返回true。
        if(i >= j) return true;
        int p = i;		//这里p指向i开始遍历
        while(postorder[p] < postorder[j]) p++;
        int m = p;		//这里m指向比根节点大的一个右子树节点
        while(postorder[p] > postorder[j]) p++;	//尝试越过根节点往右边找
        //判断此树的p是否加到了最右边，代笔这个子树有没得问题。
        return p == j 
            && recur(postorder, i, m - 1) && recur(postorder, m, j - 1);
    }
}
````

##### 方法二：单调栈 (推荐)

思路：单调递增栈

后序遍历是**左右根**，而这里是倒序遍历，也就是**跟右左**的顺序。

例子：[5，6，2，3，1]		

**跟右**：也就是一直递增的没有问题，不用校验，而如果出现了递减，那便是出现了新的**跟右**，我们只需要校验新的跟右都是小于它的最近父节点即可。跟右在代码注释里就是递增元素序列。



为了过度遍历，制造伪root节点 root = int的最大值。可把树的真实根节点看为此无穷大节点的左孩子。

倒序遍历 postorder 数组， 第一个便是根节点，如果后边是递增的，那么依次进栈。

如果说出现了递减的节点，更新 root 的值，也就是元素不断出栈，root更新为栈内最后一个元素或者说是第一个不大于递减的节点的值也就是最近父节点。

继续遍历后边的节点，之后的递增节点都要小于这个更新后的节点才算符合，如果再次出现递减重复上述逻辑。



代码设计：单调栈（单调递增） ：这样里面放 跟和右  都是递增的，而左要小于栈底的元素，也就是小于最近跟。

时间复杂度 O(N) ： 遍历所有节点，各节点均入栈 、出栈一次，使用 O(N) 时间。
空间复杂度 O(N) ： 最差情况下，单调栈 stack 存储所有节点，使用 O(N)额外空间。

````java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        Stack<Integer> stack = new Stack<>();
        //为了过度遍历，制造伪root节点，可以把postorder中的根节点看做是伪root节点的左孩子。
        int root = Integer.MAX_VALUE;
        for(int i = postorder.length - 1; i >= 0; i--) {
            //判断新的递增元素序列都要小于它的最近父节点。	有这判断反推root的初始化。
            if(postorder[i] > root) return false;
            //栈不空且出现递减元素
            while(!stack.isEmpty()&& postorder[i] < stack.peek())
                //更新root为最近父节点。
            	root = stack.pop();
            //递增的元素序列依次进栈
            stack.add(postorder[i]);
        }
        return true;
    }
}
````




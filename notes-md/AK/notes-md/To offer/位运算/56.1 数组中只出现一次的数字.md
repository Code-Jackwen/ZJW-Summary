力扣中等

力扣上还有变式题，第56.2题。



考位运算



一个整型数组 nums 里除**两个数字**之外，其他数字都出现了两次。找出只出现一次的数字。

要求时间复杂度是O(n)，空间复杂度是O(1)。

 

示例 1：

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

示例 2：

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]


限制：

2 <= nums.length <= 10000



思路：

将数组中a、b两个单个出现的特殊数字分为两组，组内所有数字都互相异或，两个一样的数字异或得出是0，而只有一个的数字最后会被剩下找到。

分组的话根据(num & diff) == 0来判断。

例如：

5、5、6、6		4、8

0100 & 4 = 0		

0100 & 8  != 0	而其他的两个数字不管分到那一边，反正一样的判断都会分到同一边，然后最终抵消掉。



原理：

1、两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。 

例如：6^5^5^6^4 得4

例如：6^5^5^6^4^8 得 4^8 得12

异或是两个数位不一样的位才为1，一样的为0，所以，8^8=0，8^0=8，任意数都是。



2、利用 diff &= -diff 得到出 diff 最右侧不为 0 的位，就可以将两个元素区分开来，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位。

例如：4^8 得 12 ，

4：0100			

8：1000			

12的位表示：1100	

根据diff &= -diff 和12**得到0100**，利用这0100**区分**开那俩个只出现一次的数。当然还有其他获取方法。



时间复杂度：O(n)，我们只需要遍历数组两次。

空间复杂度：O(1)，只需要常数的空间存放若干变量。

````java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int diff = 0;
        for (int num : nums)
            diff ^= num;

        // diff &= -diff;
        int mask = 1;
        while((diff & mask) == 0) mask <<= 1;
            
        int ret1 = 0, ret2 = 0;
        for (int num : nums) {
            if ((num & mask) == 0) ret1 ^= num;
            else ret2 ^= num;
        }
        return new int[]{ret1, ret2};
    }
}
````

补充：获取最右侧不为 0 的位的方法。

这里的mask相当于上边的diff

````java
//方法1：mask = diff & (-diff) 这种方法也可以得到mask，具体原因百度。
//方法2：常规遍历
int mask = 1;
while((diff & mask) == 0) {
    mask <<= 1;
}
//或者最后用 c 来判断
int c = 1;
while ((diff & 1) != 1) {
    c <<= 1;//注意和c <<= c; 的区别，这种<<=尽量少用。
    diff=diff>>1;
}

````


力扣中等



地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。

一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向**左、右、上、下**移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。请问该机器人能够到达多少个格子？



例如，当 k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。

但它不能进入方格 [35, 38]，因为3+5+3+8=19。

 

示例 1：

输入：m = 2, n = 3, k = 1
输出：3



提示：

1 <= n,m <= 100
0 <= k <= 20








## 方法一：深度优先遍历(Depth First Search)



思路：

DFS 是朝一个方向走到底，再回退，再朝一个方向走到底，再回退，以此类推。 

把这题的矩阵顺时针旋转45度，发现这和对树的后序遍历类似。



1、从固定的入口 (0,0) 开始搜索，只有两个方向向右边或者下边，终止条件要判断是否超过了矩阵的右边界和下边界，以及判断一个位置的数位和是否大于了输入的 k 。

2、通过回溯完成计数，以及通过全局变量 boolean[][] visited \[ ][ ] 完成不重复计数。

3、递进需要计算数位和，这里用到递进时的数位和的计算公式。

**公式**

```css
数位和递推公式：   设 x 的数位和为 sx ， x+1 的数位和为 ss_x 。
当 (x+1) %10 !=0 时，ss_x =  sx + 1
当 (x+1) %10 =0 时，ss_x =  sx - 8 
```

> 例如：18的数位和为 9，(18 + 1)%10 != 0，所以，(18 + 1)= 19 的数位和为 9 + 1= 10。
>
> 例如：19的数位和为10，(19 + 1)%10 = 0，所以，(19+1) = 20 的数位和为 10 - 8 = 2 。

> 例如：1 的数位和分别为 1，(1 + 1)%10 != 0，所以，(1+1) = 2 的数位和为 1 + 1 = 2 。 
>
> 例如：9 的数位和分别为 9，(9 + 1)%10 = 0，所以，(9+1) = 10 的数位和为 9 - 8 = 1 。 
>
> 例如：10 的数位和分别为 1，(10 + 1)%10 != 0，所以，(10 + 1) = 11 的数位和为 1 + 1 = 2 。 

代码整合后： (x + 1) % 10  != 0  ? s_x + 1 : s_x - 8 



如图：下一个访问的便是 (0，2)

![1609122105618](F:/项目/Git-md/ZJW-Summary/assets/1609122105618.png)

设矩阵行列数分别为 M,N 。

时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。
空间复杂度 O(MN) ： 最差情况下，辅助矩阵 visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。

````java
class Solution {
    int m, n, k;
    boolean[][] visited;
    public int movingCount(int m, int n, int k) {
        this.m = m; this.n = n; this.k = k;
        this.visited = new boolean[m][n];
        return dfs(0, 0, 0, 0);//从固定的入口开始搜索。
    }
    public int dfs(int i, int j, int si, int sj) {
        if(i >= m || j >= n || k < si + sj || visited[i][j]) return 0;
        //标记这个位置有个，不再被计数。
        visited[i][j] = true;
        return 1 + dfs(
            		   i + 1, 
                       j, 
                       (i + 1) % 10 != 0 ? si + 1 : si - 8,
                       sj
        			  ) 
                 + dfs(
            		   i,
                       j + 1,
                       si, 
                       (j + 1) % 10 != 0 ? sj + 1 : sj - 8
         			  );
    }
}
````

## 方法二：广度优先搜索(Breadth First Search)



思路：

BFS 则是按照“平推”的方式向前搜索。 

把这题的矩阵顺时针旋转45度，发现这和对树的层次遍历类似。



将初始点 (0, 0)放入队列中，



如图：该图下一步是要根据 绿色的（0,2）添加（0,3），但是（0,3）已是不符合数位和 k 的。

![1609126516098](F:/项目/Git-md/ZJW-Summary/assets/1609126516098.png)

如图：灰色的一层都不符合，因此也不能再往下添加新的元素，循环结束，返回 res 。

![1609126667857](F:/项目/Git-md/ZJW-Summary/assets/1609126667857.png)

设矩阵行列数分别为 M,N 。

时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。
空间复杂度 O(MN) ： 最差情况下，辅助矩阵 visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。

````java
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        int res = 0;
        Queue<int[]> queue= new LinkedList<int[]>();
        queue.add(new int[] { 0, 0, 0, 0 });
        while(queue.size() > 0) {
            int[] x = queue.poll();
            int i = x[0], j = x[1], si = x[2], sj = x[3];
            if(i >= m || j >= n || k < si + sj || visited[i][j]) continue;
            visited[i][j] = true;
            res ++;
            queue.add(new int[] { i + 1, j, (i + 1) % 10 != 0 ? si + 1 : si - 8, sj });
            queue.add(new int[] { i, j + 1, si, (j + 1) % 10 != 0 ? sj + 1 : sj - 8 });
        }
        return res;
    }
}
````



### 本题的临界点

如图，显示本题可到达位置突变的一些突变数位和临界点。

k = 8

![1609126128089](F:/项目/Git-md/ZJW-Summary/assets/1609126128089.png)

k = 9

![1609125986844](F:/项目/Git-md/ZJW-Summary/assets/1609125986844.png)

k = 10

![1609126035323](F:/项目/Git-md/ZJW-Summary/assets/1609126035323.png)



### DFS 与 BFS 比较

|      | 实现方法 | 基本思想                                             | 解决问题                         | N规模                  |
| ---- | -------- | ---------------------------------------------------- | -------------------------------- | ---------------------- |
| DFS  | 栈/递归  | 回溯法，一房间一个房间的走到尽头，再从尽头往回返回。 | 所有解问题，或连通性问题。       | 一般不能太大,<=200     |
| BFS  | 队列     | 分治限界法，一次访问多个房间，挨个进去再次查房间。   | 最优解问题，如最短路径，层次遍历 | 可以比较大，一般<=1000 |

回溯：

深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除这些状态。
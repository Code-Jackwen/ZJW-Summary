困难：[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

<img src="../../../../ZJW-Summary/assets/1624704013194.png" alt="1624704013194" style="zoom: 67%;" />

```
输入: 非负整数数组，[2,1,5,6,2,3]	输出: 10  解释：能勾勒出的最大矩形面积为 10 
```

```java
public int largestRectangleArea(int[] heights) {		//暴力，O(n2) 超时
    int n = heights.length, res = 0;
    for (int i = 0; i < n; i++) {
        int left = i - 1;
        while (left >= 0 && heights[left] >= heights[i])  left--;
        int right = i + 1;
        while (right < n && heights[right] >= heights[i]) right++;
        res = Math.max(res, heights[i] * (right - left - 1));
    }
    return res;
}
```

单调栈递增（不减）栈可以找到左边第一个比当前出栈元素小（包含等于）的元素。

单调栈递减（不增）栈可以找到左边第一个比当前出栈元素大（包含等于）的元素。

暴力法用于分析出，问题也符合后进先出顺序，以第 i 根柱子为最矮柱子所能延伸的最大面积。

哨兵技巧：在原来数组的前后加两个 0 （或者是 0.5，只要比 1 严格小都行）的柱形，可以避免掉分类讨论。

1、弹栈的时候，栈为空需要对栈判断，首部的哨兵可以一直在栈内，保证栈不空，因此减少了对栈为空的判断；

2、没有尾部哨兵时，遍历完后栈中可能还有元素，末尾的0可以清空并计算所有还在栈内的元素；	

```java
public int largestRectangleArea(int[] heights) {			//单调递减栈+哨兵
    int res = 0;											//2,1,5,6,2,3
    Deque<Integer> stack = new ArrayDeque<>();
    int[] new_heights = new int[heights.length + 2];
    for (int i = 1; i < heights.length + 1; i++) new_heights[i] = heights[i - 1];
    //System.out.println(Arrays.toString(new_heights));
    for (int i = 0; i < new_heights.length; i++) {		
        //System.out.println(stack.toString());
        while (!stack.isEmpty() && new_heights[stack.peek()] > new_heights[i]) {
            int cur = stack.pop();
            res = Math.max(res, (i - stack.peek() - 1) * new_heights[cur]);
            //System.out.print(res+",");
        }	//必须是i - stack.peek() - 1 而不是 i - cur
        stack.push(i);
    }		//(5-3-1) *6     (5-2-1) *5
    return res;  
}			//最后栈内会是最后尾部和首部0的下标出不来，不过不重要。
```

```java
public int largestRectangleArea(int[] heights) {	//原始代码，包含了3中情况的处理。
    int len = heights.length,res = 0;				//单调递减栈
    if (len == 0) return 0;
    if (len == 1) return heights[0];
    Deque<Integer> stack = new ArrayDeque<>(len);
    for (int i = 0; i < len; i++) {
        while (!stack.isEmpty() && heights[i] < heights[stack.peekLast()]) {
            int curHeight = heights[stack.pollLast()];
            while (!stack.isEmpty() && heights[stack.peekLast()] == curHeight)
                stack.pollLast();					//处理连续相同高度计算错误的情况，不处理也对
            int curWidth;							//不处理会被后边的正确计算覆盖
            if (stack.isEmpty()) curWidth = i;		//最后一个元素的情况
            else curWidth = i - stack.peekLast() - 1;
            res = Math.max(res, curHeight * curWidth);
        }
        stack.addLast(i);
    }
    while (!stack.isEmpty()) {						//处理栈内依然有元素的情况
        int curHeight = heights[stack.pollLast()];	//和上边while的代码近似
        while (!stack.isEmpty() && heights[stack.peekLast()] == curHeight)
            stack.pollLast();
        int curWidth;
        if (stack.isEmpty()) curWidth = len;
        else curWidth = len - stack.peekLast() - 1;
        res = Math.max(res, curHeight * curWidth);
    }
    return res;
}
```

  单调栈 ：「力扣」第 42、739、496、316、901、402、581 题。 
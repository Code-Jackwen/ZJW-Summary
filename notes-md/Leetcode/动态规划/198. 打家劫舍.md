力扣简单



给定一个代表每个房屋存放金额的非负整数数组，只能间隔地偷，不能连续偷两个相邻的房屋，计算一夜之内能够偷窃到的最高金额。 



示例 1：

输入：[1，2，3，1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。



示例 2：

输入：[2，7，9，3，1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2)， 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。



提示：

0 <= nums.length <= 100

0 <= nums[i] <= 400



思路：

动态规划

    初始状态：
        pre 表示 dp[k-1]
        prepre 表示 dp[k-2]
    状态转移方程：
    	每次循环，计算“偷到当前房子为止的最大金额”
    	dp[k] = max(dp[k-1], dp[k-2] + cur) 
    循环结束时：
    	pre 表示 dp[k]，prepre 表示 dp[k-1]



时间复杂度 O(N)：循环遍历的数组

空间复杂度 O(1)：滚动变量

```java
public int rob(int[] nums) {
    int prepre = 0;
    int pre = 0;
    for (int cur : nums) {
        int temp = Math.max(pre, prepre + cur);
        prepre = pre;
        pre = temp;
    }
    return pre;
}
```

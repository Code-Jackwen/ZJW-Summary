# 1. 问题描述

TopK Elements 问题用于找出一组数中最大的 K 个的数。

 此外还有一种叫 Kth Element 问题，用于找出一组数中第 K 大的数。 



如果要找的 TopK Elements 是最小的 K 个数，那么可以将问题转换成求解 TopK Elements，因为找到 Kth Element 之后，再遍历一遍，小于等于 Kth Element 的数都是 TopK Elements。 



# 2. 一般解法

## 2.1 快速选择

快速排序的 partition() 方法，对于数组 nums 的 [l, h] 区间，会返回一个整数 k 使得 nums[l..k-1] 小于等于 nums[k]，且 nums[k+1..h] 大于等于 nums[k]，此时 nums[k] 就是数组的第 k 大元素。

可以利用这个特性找出数组的 Kth Element，这种找 Kth Element 的算法称为快速选择算法。

利弊分析：

- 时间复杂度 O(N)、空间复杂度 O(1)：未计算栈空间，最差栈空间O(N)。
- 只有当允许修改数组元素时才可以使用

## 2.2 堆

维护一个大小为 K 的小跟堆或者大根堆，遍历一遍并添加、剔除堆中数据，最后堆顶元素就是 Kth Element。

- 时间复杂度 O(NlogK) 、空间复杂度 O(K)
- 特别适合处理海量数据

# 3. 海量数据

在这种场景下，单机通常不能存放下所有数据。

- 拆分，可以按照哈希取模方式拆分到多台机器上，并在每个机器上维护最大堆；
- 整合，将每台机器得到的最大堆合并成最终的最大堆。

# 4. 频率统计

Heavy Hitters 问题要求找出一个数据流的最频繁出现的 K 个数，比如热门搜索词汇等。

使用 HashMap 进行频率统计，然后使用堆的方式找出频率 TopK。

在海量数据场景下，也是使用先拆分再整合的方式来解决空间问题。
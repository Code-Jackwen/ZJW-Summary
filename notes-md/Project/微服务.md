## CAP理论

**Consistency 一致性**：即所有节点在同一时间的**数据完全一致**。 

- 强一致性

对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。

- 弱一致性

如果能容忍后续的部分或者全部访问不到，则是弱一致性。

- 最终一致性

如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。

**Availability 可用性**：

即服务在正常响应时间内一直**可用**。 

**Partition tolerance分区容错性** ：

分区相当于对通信的时限要求 



## BASE理论

BASE理论是Basically Available(**基本可用**)，Soft State（**软状态**）和Eventually Consistent（**最终一致性**）三个短语的缩写。 

**核心思想**： 

既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。 



**一、基本可用**

假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：

1、 **响应时间变长**  

 **搜索引擎0.5**秒即返回给用户结果，而基本可用的搜索引擎可以在**2秒**作用返回结果 

2、 **功能上的损失** 

电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，**为了保护购物系统的稳定性**，部分**消费者可能会被引导到一个降级页面**。 



**二、软状态**

相对于原子性而言，要求**多个节点的数据副本都是一致**的，这是一种“**硬状态**”。

**软状态**指的是：**允许**系统中的数据存在**中间状态**，并认为该状态不影响系统的**整体可用性**，即**允许**系统在多个不同节点的数据**副本存在数据延时**。



**三、最终一致性**

上面说软状态，然后不可能一直是**软状态**，必须有个**时间期限**。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限**取决于网络延时、系统负载、数据复制**方案设计等等因素。 

**1、因果一致性**

果节点A在更新完某个数据后**通知了节点B**，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制，也就是**AB之间最新，AC之间不必最新**。 

**2、读己之所写**

节点**A更新一个数据后**，它自身**总是**能访问到**自身**更新过的**最新值，**而不会看到旧值。其实**也算一种因果一致性**。 

**3、会话一致性**

将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个**有效的会话**中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。 

**4、单调读一致性**

如果**一个节点从系统中读取出一个数据项的某个值**后，那么系统对于该节点后续的任何数据访问都**不应该**返回**更旧**的值。 

**5、单调写一致性**

一个系统要能够保证**来自同一个节点的写操作被顺序的执行**。 

例子：

关系型数据库在某个功能上，也是使用最终一致性的。

比如**备份**，**数据库的复制**过程是需要时间的，这个复制过程中，**业务读取到的值就是旧的**。当然，**最终还是达成了数据一致性**。

BASE提出通过**牺牲强一致性来获得可用性**，**并允许数据段时间内的不一致，但是最终达到一致状态**。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。在设计中，ACID和BASE理论往往又会结合使用。 



参考：

https://juejin.cn/post/6844903621495095304

## 2PC协议

由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。

其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 Phase Commitment Protocol）和Paxos算法。

拿事务来说，2PC协议，分为两个阶段提交一个事务。并通过协调者和各个参与者的配合，实现分布式一致性。 

- 优点：原理简单，实现方便。
- 缺点：同步阻塞，单点问题，数据不一致，容错性不好。

**同步阻塞**

在二阶段提交的过程中，**所有的节点都在等待其他节点的响应**，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。

**单点问题**

协调者在整个二阶段提交过程中很重要，如果**协调者在提交阶段出现问题**，那么整个流程将**无法运转**。更重要的是，其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。

**数据不一致**

假设当协调者向所有的参与者发送commit请求之后，发生了**局部网络异常**，或者是协调者在尚未发送完所有 commit请求之前自身发生了崩溃，导致最终**只有部分参与者收到了commit请求**。这将导致严重的**数据不一致问题**。

**容错性不好**

如果在二阶段提交的提交询问阶段中，**参与者出现故障**，导致协调者始终无法获取到所有参与者的确认信息，这时**协调者只能依靠其自身的超时机制**，判断是否需要**中断事务**。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的**容错机制**，任意一个节点是失败都会导致整个事务的失败。



参考：

https://juejin.cn/post/6844903621495095309



## 3PC协议

与两阶段提交不同的是，三阶段提交有两个改动点。 

1、**同时在协调者和参与者中都引入超时机制****。

2、在第一阶段和第二阶段中插入一个**准备阶段**，保证了在最后**提交阶段之前各参与节点的状态是一致**的。

所谓的三个阶段分别是：询问，然后再锁资源，最后真正提交。 



主要说下二阶段：

**PreCommit**

协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。

**1、执行事务预提交**

**发送预提交请求**：

协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。

**事务预提交**：

参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 准备阶段中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中。 

**各参与者响应反馈**：

如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）。 





**2、中断事务**

发送中断请求：协调者向所有参与者节点发出 abort 请求 

 中断事务：参与者如果收到 abort 请求或者超时了，都会中断事务。 



**优点**

相对于二阶段提交，三阶段提交主要解决的**单点故障问题**，并减少了**阻塞的时间**。

因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。

**缺点**

三阶段提交也会导致数据**一致性问题**。由于网络原因，协调者发送的 **abort 响应没有及时被参与者接收到**，那么参与者在等待超时之后执行了 **commit** 操作。

这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。



参考：

https://juejin.cn/post/6844903621495111688



## 脑裂问题

## 定义

在一个高可用系统中，当联系着的节点断开联系时，本来为一个整体的系统，分裂成两个独立节点，两个节点开始争抢共享资源造成系统混乱、数据损坏的现象，成为“脑裂”。

双主同时存在的问题，规避该问题的核心是隔离，保证系统识别得到唯一主，剔除掉失效主节点。

## 原因

主要原因: 心跳检测做准备切换时的“不确定性”

当网络原因，导致心跳检测超时，主备切换的情况下，此时slave已经开始提供服务。但是后续之前被判定“死”的master由于网络恢复重新“复活”，此时系统存在两个“主”，发生脑裂问题； 

## 解决思路

解决脑裂问题，有三种常用思路，分别如下：

- 设置仲裁机制
- lease机制
- 设置隔离机制

 **仲裁机制**

设置仲裁机制的方案通常是设置一个第三方检测服务器，当slave确定准备接管master 时候，manitor会ping以下master，如果master未回复，则判定其死亡！ 

评价：仲裁机制的主要问题是monitor存在高可用性能瓶颈！ 

**分布式授权承诺机制**

todo

**隔离机制**

todo

**总结**：

- 仲裁机制是引入第三方检测器的方式，定时检测保障主存活；
- lease方式则是以认证凭据方式，保障切换后，老主失效；



参考：

https://blog.csdn.net/xinquanv1/article/details/103126372



## Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别

1、ZooKeeper保证的是CP,Eureka保证的是AP

ZooKeeper在**选举期**间注册服务**瘫痪**,虽然服务**最终会恢复**,但是选举期间不可用的

Eureka各个**节点是平等关系**,只要有一台Eureka就可以保证服务**可用**,而查询到的**数据并不是最新**的

自我保护机制会导致

Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务

Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)

当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)

Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪



2、ZooKeeper有Leader和Follower角色,Eureka各个节点平等

3、ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题

## 羊群效应

实现的分布式锁可能会产生羊群效应 

如果几十个客户端同时争抢一个锁，此时会导致任何一个客户端释放锁的时候，zk反向通知几十个客户端，几十个客户端又要发送请求到zk去尝试创建锁，所以大家会发现，几十个人要加锁，大家乱糟糟的，无序的。

羊群效应，造成很多没必要的请求和网络开销，会加重网络的负载



## 分布式锁的实现

参考：

https://fantastickb.com/posts/distributed_lock/



## Ribbon和Feign的区别？

1、启动类**注解不同**，Ribbon是**@RibbonClient**，feign的是**@EnableFeignClients**

2、**服务指定的位置**不同，Ribbon是在**@RibbonClient注解上声明**，Feign则是在定义**抽象方法的接口中使用@FeignClient**声明。

3、调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。
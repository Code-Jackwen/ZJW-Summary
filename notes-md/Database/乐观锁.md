## 1. 并发控制

##### 事务：

它是一组操作，并且满足 ACID 特性。

多个事务并发执行可以看成是多个任务线程的并发执行，因此并发执行多个事务时，为了保证每个事务都具有 ACID 特性，也同样需要使用并发控制。 



##### 悲观和乐观并发控制

是主要的两种并发控制方法，应该注意到它们都是思想，而不是具体的实现。



## 2、悲观并发控制

### synchronized  实现

Java 中的 synchronized  就是悲观锁思想的体现。

### 数据库中的实现

在数据库管理系统中提供了两种锁：共享锁（S）和排它锁（X），也称为**读锁和写锁**。

- 一个事务对数据 A 加了 X 锁，就可以对 A 进行读取和更新，加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作，加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

##### 悲观评价

悲观并发控制能够保证线程安全性，但是无论共享数据是否真的会出现竞争，它都要进行加锁。

而加锁操作需要涉及用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作，代价非常高。

所以悲观并发控制只适合**共享数据经常出现竞争的场景**，但是对于共享数据基本不会出现竞争的场景，它花费了很多不必要的锁开销。 



## 3. 乐观并发控制

针对悲观并发控制对于共享数据基本不会出现竞争的情况下也需要加锁的问题，出现了乐观并发控制。

它保持乐观的态度，认为并发执行过程不会对共享数据出现竞争问题。

它只在修改数据之后检测一下修改期间该共享数据有没有出现竞争问题，也就是说有没有其它线程也同样修改了该共享数据，如果没有则修改成功，如果有则需要重做。 

### CAS 实现

CAS 指令是硬件支持的操作：比较并交换（Compare-and-Swap）。

Java 中的 AtomicInteger 使用 CAS 来实现。

底层要追溯到 unsafe 类，类中很多 native 修饰的方法。

AtomicInteger 的核心代码是 getAndAddInt()，其中 var1 是内存地址 V，getIntVolatile(var1, var2) 得到旧值 A，而 var5 + var4 是新值 B。可以看到在检测到冲突时，AtomicInteger 采用不断重试的方式，直到不再发生冲突为止。 

核心代码：

````java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    return var5;
}
````

##### CAS 存在的 ABA 问题

如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过，这就是 ABA 问题。

##### ABA 问题的解决

J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。

 

### 版本号实现

在数据库管理系统中，可以为表增加一个 version 列，那么每个记录就可以维护一个版本号，每次修改时版本号加 1。

在对记录进行修改之前先读出 version，并在修改后判断 version 是否发生改变。如果没有发生改变就表示没有发生冲突，执行提交，否则回滚。

![1609658732975](../../assets/1609658732975.png)

```sql
start transaction;
select version from t_goods where id=#{id};
update t_goods set status=2,version=version+1 where id=#{id} and version=version;
commit;
```
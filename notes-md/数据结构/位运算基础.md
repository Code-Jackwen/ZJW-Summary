# 位运算基础

### 1、& 与

&：都一则一

0&0=0  0&1=0  1&0=0  1&1=1

#### 用途

1）清零

0&n=0



2）取一个数的指定位

比如取数 X=1010 1110 的低4位，令Y的低4位为1，即Y=0000 1111，然后（X&Y=0000 1110）即可得到X的指定位。

例子：获取 X=1010 1110 前四位，用Y=0000 1111，得：X&Y=0000 1110



3）判断奇偶

可以用 if ((a & 1) == 0) 代替 if (a % 2 == 0) 来判断a是不是偶数。



4）取最低位的1对应的整数

diff &= -diff 得到出 diff 最右侧不为 0 的位，例如：(68)1000100 => (4)100

(-68)11111111111111111111111110111100

参考：中等： [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)



5）去除一个数最低数位的1

使用 z & ( z - 1 ) 去除 z 位级表示最低的那一位，例如：(7)0111 => (3)011

z => (7)0111 & z-1 => (6)110

参考：简单： [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)	



6）删除指定位置的1

```js
//位运算：删除指定位置的1
int num = ...;   // 原始的整数
int pos = ...;   // 要删除的位的位置
//~ 取反，会把所有位置的1变为0、0变为1						
int mask = ~(1 << pos);   // 创建一个掩码，只有第 pos 位为 0，其它位为 1。  debug：010 => 101
int result = num & mask;  // 与操作，将第 pos 位上的 1 删除。	debug：101 & 111 => 101
//PS：而题解中 used ^= 1 << i; // 将第 i 位置为 0，前提是 第 i 位置 必须就是 1，并不是标准！
```



7）环形数组

不建议用，arr.length需要是 2的幂 才能用...

```java
// 在环形数组中转圈，进而代替 print(arr[index % arr.length]);
print(arr[index & (arr.length - 1)]);
```



8）：

n&(n-1)==0，快速判断一个数是否是2的n次幂，也能删除最右边的一个1。

case1：8 的二进制数 1000 ，7 二进制数 111

case2：7 的二进制数 111，6 的二进制数 110



9）：

例如：

 (0000...111100) 传入 lowbit 返回 (0000...000100) 

   (0000...00011) 传入 lowbit 返回 (0000...00001)	

```java
int lowbit(int x) {	//返回的是具体十进制的数
    return x & -x;
}
```



其他应用二：(不常用)

一个数 n 与一个 2^n  求余，就等于 n&(2^n  -1) 。

例1：

二进制：11111 % 1000 =  11111 & 111 = 111

十进制：69+2+8=79 %  8 = 7

例2：

二进制：10101 % 10  = 10101 & 1 = 1

十进制：1+4+64 =69 % 2 = 1



### 2、| 或

|：有1则1

0|0=0  0|1=1  1|0=1  1|1=1

#### 用途

1）常用来对一个数据的某些位设置为1



2）俗称：位运算里的加法

​	   ans |= (1 << i)				//用一个位一个位的构造新数字，就像字符串拼接

​       ret |= (n & 1);				//|=这个俗称位运算的加法，按照一个bit一个bit加起来



### 3、^异或		


0^0=0  0^1=1  1^0=1  1^1=0

^：同 0 异 1，看两者是相同还是不相同。

```java
System.out.println(true ^ true);//f
System.out.println(true ^ false);//t
System.out.println(false ^ false);//f
```



异或的几条性质:

1、交换律

a^b = b^a

2、结合律 

(a \^ b) ^ c == a \^ (b ^ c)

3、自反性:

a\^b\^b=a^0=a

对于任何数x，都有 x\^x=0，x^0=x



#### 用途

1）交换两个数

void Swap(int &a, int &b){
    if (a != b){
        a ^= b;
        b ^= a;
        a ^= b;
    }
}



2）指定数位的取反

不标准！

前提需要知道指定位置的是1还是0才能知道用0还是1 去让它反过来

标准的需要用 & 结合 ~ 来做

1110 ^**1111**得0001



3）奇、偶数操作

用处不大

奇数mid ^ 1 = mid - 1, 偶数mid ^ 1 = mid + 1



4）用来抵消一个数组里相同数字，去重

例如：1、1、1、1、3 的数组获取3



5）判断是否异号

```java
int x = -1, y = 2;
boolean f = ((x ^ y) < 0); // true

int x = 3, y = 2;
boolean f = ((x ^ y) < 0); // false
```



### 4、 ~

取反运算符
~1=0	~0=1
二进制内部的 0变1，1变0

```
应用例如：取反后，大小上会 -1 
68与~68 ：是68与-69，1000100 => 1111111111111111111111111 0111 011
100与~100：是100与-101，1100100 => 11111111111111111111111110011011
1与 ~1  ：是1变-2 	1 => 11111111111111111111111111111110
```

### 5、<<

若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。

### 6、>>

每右移一位，相当于该数除以2。

例如 -7 \>\> 2 = -2。实际这个移动，左边会补充 1 ，也就是带上 符号 - 进行右移，如果是正数那左边补充的是 0。

常用来扣最低位的1。例如：t = ((num >> i) & 1)

### 7、\>\>\> 

\>\>\> n 为无符号右移，左边会补上 0，而不是 1 ，不论是正数还是负数。	例如 -7 \>\>\> 2 = 1073741822。

```
11111111111111111111111111111001  >>> 2
--------
00111111111111111111111111111111
```

### 8、mask 计算 

要获取 111111111，将 0 取反即可，\~0。

要得到只有第 i 位为 1 的 mask（即mask就是 1），将 1 向左移动 i-1 位即可，1\<\<(i-1) 。例如 1\<\<4 得到只有第 5 位为 1 的 mask ：00010000。

要得到 1 到 i 位为 1 的 mask，(1\<\<i)-1 即可，例如将 (1\<\<4)-1 = 00010000-1 = 00001111。

要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 \~((1\<\<i)-1)。

# Java相关函数

```java
static int Integer.bitCount();           // 统计 1 的数量
static int Integer.highestOneBit();      // 获得最高位
static String toBinaryString(int i);     // 转换为二进制表示的字符串
```


## 满二叉树：

国内定义：

每一个层的结点数都达到最大值，二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
国外定义：一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。
国内内外两种定义，国内就是个等腰三角形，国外：可以不是对称的。

从外形来看，满二叉树是一个等腰三角形。
节点总数：n=2^k  -1,k表示深度，也就是层数
第i层的节点数n= 2^(i- 1)
深度确定后，总节点数，每层的节点数都是是一系列固定的数，如果不是序，就不是满二叉树。



## 完全二叉树：

满二叉树一定是完全二叉树、但是完全二叉树未必是man二叉树
树的样子：最后一层叶子节点可以像mysql最左原则那样，但是不能中间空出来。整个树可以不对称
树的最后一层相比满二叉树，可以出现节点缺失，但所缺失的部分一定是右下角某个连续的部分。
对于k层的完全二叉树，节点数的范围2^ (k - 1) -1 < N< 2^k - 1



## B树：

英语：B-tree，二叉查找树（binary search tree），也是自平衡的树，一个节点可以拥有2个以上的子节点。



在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。

当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被**合并或者分离**。因为子节点数量有一定的允许范围，所以B树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，**可能浪费了一些空间**。子节点数量的**上界和下界**依特定的实现而设置。例如，在一个2-3 B树（通常简称[2-3树](https://zh.wikipedia.org/wiki/2-3树)），每一个内部节点只能有2或3个子节点。 

  

##### 键

B树中每一个内部节点会包含一定数量的键，键将节点的子树分开。
例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键。左边子树的所有值都必须小于，中间子树的所有值都必须在之间，右边子树的所有值都必须大于。     





##### 存储

B树适用于读写相对大的数据块的存储系统。通过最大化内部里层节点的子节点的数量，树的高度减小，存取节点的开销被缩减。另外，重新平衡树的动作也更少出现。 子节点的最大数量取决于，每个子节点必需存储的信息量，和完整磁盘块的大小或者二次存储器中类似的容量。 



## B+树



B树的变体， 通常用于数据库、文件系统、操作系统。

键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。 



任意节点的子树的高度差都小于等于1。

常见的有：B树（多路平衡搜索树）、len树（二叉平衡搜索树）。
         





##  2-3树：

最简单的B-树（平衡树），不是二叉树，可以有三个叉，三个叉的叫2-节点。
要求：每个 非叶节点 ！都有两个或三个子女，而且所有叶都在统一层上（底部是平的），从根到叶的每条路径都是等长的
对比慢二叉树：高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。
添加规则：
2-的节点须有有1个数据项，用来比较左右孩子大小。
3-的节点须有有2个数据项，用来比较左右孩子大小。
叶子节点可以包含一个或两个数据项



- 



2-3树是一种自平衡的树型数据结构，常用于实现有序映射（Ordered Map）或有序集合（Ordered Set）。它有以下主要特点：

1. **节点类型：** 2-3树的节点可以包含1个或2个键（key），分别对应一个或两个子树。这使得2-3树的节点可以有两种类型：
   - 2-节点：包含一个键和两个子树。
   - 3-节点：包含两个键和三个子树。
2. **有序性质：** 2-3树保持有序性质。对于任意节点，左子树中的所有键小于节点的第一个键，右子树中的所有键大于节点的第二个键（如果存在）。
3. **平衡性：** 2-3树是一种平衡树，即从根节点到任意叶子节点的路径长度相等。这确保了基本操作（插入、删除、查找）的平均时间复杂度是常数级别。
4. **插入和删除：** 插入和删除操作可以导致树的重新平衡，通常涉及到节点的分裂、合并和键的重新分配。这些操作保持了2-3树的平衡性质。
5. **变种：** 2-3树有两个变种，包括2-3树和2-3-4树。在2-3树中，每个节点可以有1个或2个键，而在2-3-4树中，每个节点可以有1个、2个或3个键，分别对应1个、2个或3个子树。
6. **应用：** 2-3树常用于实现数据库索引、文件系统中的目录结构以及其他需要有序性和平衡性的数据结构。

总之，2-3树是一种自平衡的有序树结构，通过节点类型的变化和重新平衡操作来维持有序性和平衡性。它在数据库和文件系统等应用中具有重要的作用，以确保高效的数据检索和维护。



## 哈希表：

也叫散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。
它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
散列函数：
这个映射函数叫做散列函数
散列表：
存放记录的数组。
例子：
给定表M，存在函数f(key)，对任意给定的关键字值key，
代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，
函数f(key)为哈希(Hash) 函数。





## AVL树：

二叉搜索树

Adelson-Velsky和E. M. Landis发表论文，AVL树诞生。
任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。，通过一次或多次树旋转，维持平衡
插入和删除在平均和最坏情况下的时间复杂度都是O(logN)

节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。
带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。
平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。

区别：
和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。
红黑树的crud综合性能更好些，AVL单说查询很好。而map的实现只是折衷了两者在search、insert以及delete下的效率
**红黑树任何不平衡都会在三次旋转之内解决。红黑是用非严格的平衡来换取增删节点时候旋转次数的降低。**
而AVL旋转次数视情况不同会很不同。
 删除：红黑树旋转三次以内，O(1)，而AVL树旋转可能O(logN)次

应用，实际红黑树应用的多，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。

应用：
 AVL树，Windows NT内核。



- 







## 红黑树：

一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树）
它可以在(log n)时间内完成查找、插入和删除。红黑树对每次插入或删除需要(log n)的空间。

应用：
Java的的的中TreeMap中的中的实现
**Nginx的的的中用红黑树管理定时器，因为红黑树是有序的，可以很快的得到距离当前最小的定时器;**
**IO多路复用的epoll的的的实现采用红黑树管理的的socked，以支持快速的增删改查;**
Linux的的进程调度的完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间;
广泛用于C ++的STL中，地图和集都是用红黑树实现的

 

- 

红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（Binary Search Tree），它在维持有序性的同时，通过一系列规则来保持树的平衡。这些规则确保了树的高度保持在对数范围内，从而保证了基本操作（插入、删除、查找）的时间复杂度是 O(log n)。

以下是红黑树的主要特点和规则：

1. **节点颜色：** 每个节点都被标记为红色或黑色。
2. **根节点：** 根节点必须是黑色。
3. **红色节点规则：** 红色节点的子节点必须是黑色。这意味着不能有两个相邻的红色节点，因为这会违反了平衡性的要求。
4. **黑色高度规则：** 从根节点到叶子节点（NIL节点或空节点）的任何路径上，黑色节点的数量必须相同。这保证了树的高度保持平衡。
5. **叶子节点：** 叶子节点被认为是黑色的。在某些实现中，也可以将叶子节点定义为NIL节点。

红黑树的自平衡性质是通过插入和删除操作中的颜色变换和旋转来维护的。这些操作被精心设计，以确保不会破坏红黑树的规则，同时保持树的平衡。

关于红黑树的一些重要性质和性能特点包括：

- 红黑树的高度始终保持在 O(log n) 范围内，其中 n 是树中节点的数量。这使得它在插入、删除和查找操作上具有良好的性能。
- 插入和删除操作的平均和最坏情况时间复杂度都是 O(log n)。这是因为红黑树在这些操作中能够迅速调整以保持平衡。
- 红黑树被广泛用于各种编程语言和数据结构库中，如Java的`TreeMap`和`TreeSet`，C++的`std::map`和`std::set`，以及操作系统内核中的进程调度等场景。

总之，红黑树是一种自平衡的二叉搜索树，通过节点颜色和规则来维持平衡，以确保高效的插入、删除和查找操作，同时保持树的高度在对数范围内。这使得它成为广泛用于各种应用中的重要数据结构。



- 



1. **二叉搜索树性质：** 每个节点都有一个键值，且节点的左子树包含的键值小于节点自身的键值，右子树包含的键值大于节点自身的键值。这个性质保证了树的有序性，使得查找、插入和删除操作的时间复杂度为O(log n)，其中 n 是树中节点的数量。
2. **自平衡性质：** 为了确保树的平衡性，红黑树引入了一些规则：
   - 每个节点要么是红色，要么是黑色。
   - 根节点是黑色的。
   - 每个叶子节点（NIL节点，通常表示为黑色）是黑色的。
   - 如果一个节点是红色的，那么它的两个子节点必须都是黑色的（也就是不存在连续的红色节点）。
   - 从任意节点到其每个叶子的路径都包含相同数量的黑色节点，这被称为黑高度相等。

这些规则确保了红黑树在插入和删除节点时能够自动进行平衡操作，以维持树的平衡性。由于这些自平衡的性质，**红黑树的最长路径不会超过最短路径的两倍**，因此它具有较为稳定的性能，适用于各种需要高效查找、插入和删除操作的应用场景，如在编程语言的集合实现、数据库索引和调度算法中广泛应用。



## 伸展树：

自我平衡的二叉查找树，它能在均摊O(logN)的时间完成基于伸展的插入、查找、修改和删除操作。1985年国外人发明。



伸展：
当一个节点x被访问过后，伸展操作会将x移动到根节点。
为了进行伸展操作，我们会进行一系列的旋转，每次旋转会使x离根节点更近。
通过每次访问节点后的伸展操作，最近访问的节点都会离根节点更近，且伸展树也会大致平衡。
因此，期望均摊时间复杂度的下界——均摊O(log n)。



 优点：
无存储所需的内存少：需记录额外的什么值来维护树的信息，相对于其他平衡树，内存占用要小。
可靠的性能：它的平均效率不输于其他平衡树[2]。



缺点：
可能会变成一条链，实际时间效率可能很低。但均摊的最坏情况是对数级的——O(log n)。
即使以“只读”方式访问伸展树，其结构也可能会发生变化。多线程环境下会变得很复杂。需要额外的维护和操作。

​    



## LSM (Log-Structured Merge-Tree) 树

todo
## 满二叉树：

国内定义：

每一个层的结点数都达到最大值，二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
国外定义：一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。
国内内外两种定义，国内就是个等腰三角形，国外：可以不是对称的。

从外形来看，满二叉树是一个等腰三角形。
节点总数：n=2^k  -1,k表示深度，也就是层数
第i层的节点数n= 2^(i- 1)
深度确定后，总节点数，每层的节点数都是是一系列固定的数，如果不是序，就不是满二叉树。



## 完全二叉树：

满二叉树一定是完全二叉树、但是完全二叉树未必是man二叉树
树的样子：最后一层叶子节点可以像mysql最左原则那样，但是不能中间空出来。整个树可以不对称
树的最后一层相比满二叉树，可以出现节点缺失，但所缺失的部分一定是右下角某个连续的部分。
对于k层的完全二叉树，节点数的范围2^ (k - 1) -1 < N< 2^k - 1



## B树：

英语：B-tree，二叉查找树（binary search tree），也是自平衡的树，一个节点可以拥有2个以上的子节点。



在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。

当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被**合并或者分离**。因为子节点数量有一定的允许范围，所以B树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，**可能浪费了一些空间**。子节点数量的**上界和下界**依特定的实现而设置。例如，在一个2-3 B树（通常简称[2-3树](https://zh.wikipedia.org/wiki/2-3树)），每一个内部节点只能有2或3个子节点。 

  

##### 键

B树中每一个内部节点会包含一定数量的键，键将节点的子树分开。
例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键。左边子树的所有值都必须小于，中间子树的所有值都必须在之间，右边子树的所有值都必须大于。     





##### 存储

B树适用于读写相对大的数据块的存储系统。通过最大化内部里层节点的子节点的数量，树的高度减小，存取节点的开销被缩减。另外，重新平衡树的动作也更少出现。 子节点的最大数量取决于，每个子节点必需存储的信息量，和完整磁盘块的大小或者二次存储器中类似的容量。 



## B+树



B树的变体， 通常用于数据库、文件系统、操作系统。

键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。 



任意节点的子树的高度差都小于等于1。

常见的有：B树（多路平衡搜索树）、len树（二叉平衡搜索树）。
         





##  2-3树：

最简单的B-树（平衡树），不是二叉树，可以有三个叉，三个叉的叫2-节点。
要求：每个 非叶节点 ！都有两个或三个子女，而且所有叶都在统一层上（底部是平的），从根到叶的每条路径都是等长的
对比慢二叉树：高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。
添加规则：
2-的节点须有有1个数据项，用来比较左右孩子大小。
3-的节点须有有2个数据项，用来比较左右孩子大小。
叶子节点可以包含一个或两个数据项





## 哈希表：

也叫散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。
它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
散列函数：
这个映射函数叫做散列函数
散列表：
存放记录的数组。
例子：
给定表M，存在函数f(key)，对任意给定的关键字值key，
代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，
函数f(key)为哈希(Hash) 函数。





## AVL树：

Adelson-Velsky和E. M. Landis发表论文，AVL树诞生。
任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。，通过一次或多次树旋转，维持平衡
插入和删除在平均和最坏情况下的时间复杂度都是O(logN)

节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。
带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。
平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。

区别：
和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。
红黑树的crud综合性能更好些，AVL单说查询很好。而map的实现只是折衷了两者在search、insert以及delete下的效率
红黑树任何不平衡都会在三次旋转之内解决。红黑是用非严格的平衡来换取增删节点时候旋转次数的降低。
而AVL旋转次数视情况不同会很不同。
 删除：红黑树旋转三次以内，O(1)，而AVL树旋转可能O(logN)次

应用，实际红黑树应用的多，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。

应用：
 AVL树，Windows NT内核。





## 红黑树：

一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树）
它可以在(log n)时间内完成查找、插入和删除。红黑树对每次插入或删除需要(log n)的空间。

应用：
Java的的的中TreeMap中的中的实现
Nginx的的的中用红黑树管理定时器，因为红黑树是有序的，可以很快的得到距离当前最小的定时器;
IO多路复用的epoll的的的实现采用红黑树管理的的socked，以支持快速的增删改查;
Linux的的进程调度的完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间;
广泛用于C ++的STL中，地图和集都是用红黑树实现的

​    

## 伸展树：

自我平衡的二叉查找树，它能在均摊O(logN)的时间完成基于伸展的插入、查找、修改和删除操作。1985年国外人发明。



伸展：
当一个节点x被访问过后，伸展操作会将x移动到根节点。
为了进行伸展操作，我们会进行一系列的旋转，每次旋转会使x离根节点更近。
通过每次访问节点后的伸展操作，最近访问的节点都会离根节点更近，且伸展树也会大致平衡。
因此，期望均摊时间复杂度的下界——均摊O(log n)。



 优点：
无存储所需的内存少：需记录额外的什么值来维护树的信息，相对于其他平衡树，内存占用要小。
可靠的性能：它的平均效率不输于其他平衡树[2]。



缺点：
可能会变成一条链，实际时间效率可能很低。但均摊的最坏情况是对数级的——O(log n)。
即使以“只读”方式访问伸展树，其结构也可能会发生变化。多线程环境下会变得很复杂。需要额外的维护和操作。

​    




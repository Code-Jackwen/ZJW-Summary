链接：https://www.nowcoder.com/questionTerminal/b49c3dc907814e9bbfa8437c251b028e来源：牛客网



力扣困难



将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表 

如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样

你不能更改节点中的值，只能更改节点本身。

要求空间复杂度 O(1) 

例如： 

给定的链表是1→2→3→4→5

对于   k=2, 你应该返回 2→1→4→3→5

对于   k=3, 你应该返回 3→2→1→4→5

2 1 null 



3 4 5

示例1

## 输入

```
{1,2,3,4,5},2
```

## 输出

```
{2,1,4,3,5}
```



版本一过程图

![1611675878267](../../../assets/1611675878267.png)

## 版本一：

````java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null){
            return head;
        }
        //定义一个假的节点。
        ListNode dummy=new ListNode(0);
        //假节点的next指向head。
        // dummy->1->2->3->4->5
        dummy.next=head;
        //初始化pre和end都指向dummy。pre指每次要翻转的链表的头结点的上一个节点。end指每次要翻转的链表的尾节点
        ListNode pre=dummy;
        ListNode end=dummy;

        while(end.next!=null){
            //循环k次，找到需要翻转的链表的结尾,这里每次循环要判断end是否等于空,因为如果为空，end.next会报空指针异常。
            //dummy->1->2->3->4->5 若k为2，循环2次，end指向2
            for(int i=0;i<k&&end != null;i++){
                end=end.next;
            }
            //如果end==null，即需要翻转的链表的节点数小于k，不执行翻转。
            if(end==null){
                break;
            }
            //先记录下end.next,方便后面链接链表
            ListNode next=end.next;
            //然后断开链表
            end.next=null;
            //记录下要翻转链表的头节点
            ListNode start=pre.next;
            //翻转链表
            pre.next=reverse(start);
            //翻转后头节点变到最后。通过.next把断开的链表重新链接。
            start.next=next;
            //翻转结束，回到下一的初始状态。
            pre=start;
            end=start;
        }
        return dummy.next;
    }
    //链表翻转
    // 例子：   head： 1->2->3->4
    public ListNode reverse(ListNode head) {
         //单链表为空或只有一个节点，直接返回原单链表
        if (head == null || head.next == null){
            return head;
        }
        ListNode preNode = null;
        ListNode curNode = head;
        ListNode nextNode = null;
        while (curNode != null){
            nextNode = curNode.next;
            
            curNode.next=preNode;//将当前节点next域指向前一个节点   null<-1<-2<-3<-4
            preNode = curNode;
            
            curNode = nextNode;
        }
        return preNode;
    }
}
````



版本二：

````java
public class Solution {
    public static ListNode reverseKGroup(ListNode head, int k) {
		if(head == null || head.next == null || k < 2) return head;
		ListNode dummy = new ListNode(0);
		dummy.next = head;
		ListNode pre = dummy, cur = head, temp;
		int len = 0;
		while (head != null) {
			len ++ ;
			head = head.next;
		}
		for (int i = 0; i < len / k; i ++ ) {
			for (int j = 1; j < k; j ++ ) {
				temp = cur.next;
                
				cur.next = temp.next;
				temp.next = pre.next;
                
				pre.next = temp;
			}
			pre = cur;
			cur = cur.next;
		}
		return dummy.next;
	}
}
````




牛客在线编程研发最爱考

NC78



剑指原题：[**40. 最小的 K 个数**](https://github.com/Code-Jackwen/ZJW-Summary/blob/main/notes-md/To%20offer/%E6%8E%92%E5%BA%8F/40.%20%E6%9C%80%E5%B0%8F%E7%9A%84%20K%20%E4%B8%AA%E6%95%B0.md)



````java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length == 0) {
            return new int[0];
        }
        // 最后一个参数表示我们要找的是下标为k-1的数
        return quickSearch(arr, 0, arr.length - 1, k - 1);
    }

    private int[] quickSearch(int[] nums, int l, int h, int k) {
        // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数。
        int j = partition(nums, l, h);
        if (j == k) {
            return Arrays.copyOf(nums, j + 1);
        }
        // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
        return j > k? quickSearch(nums, l, j - 1, k): quickSearch(nums, j + 1, h, k);
    }
    // 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
     private int partition(int[] nums, int l, int h) {
        int i = l, j = h, tag = nums[l], t;
        while (i < j) {
            while (tag <= nums[j] && i < j) {
                j--;
            }
            while (tag >= nums[i] && i < j) {
                i++;
            }
            if (i < j) {
                t = nums[j];
                nums[j] = nums[i];
                nums[i] = t;
            }
        }
        nums[l] = nums[i];
        nums[i] = tag;
        return j;
    }
    
}
````


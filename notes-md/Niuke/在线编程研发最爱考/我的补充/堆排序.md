## 堆

堆中某个节点的值总是大于等于或小于等于其子节点的值，并且堆是一颗完全二叉树。

堆可以用数组来表示，这是因为堆是完全二叉树。

位置 k 的两个子节点的位置分别为 2k+1和 2k+2。

### 上浮和下沉

在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为**上浮**。

类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为**下沉**。一个节点如果有两个子节点，**应当与两个子节点中最大那个节点进行交换**。 

### 插入元素

将新元素放到数组末尾，然后上浮到合适的位置。 

### 删除最大元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。 



## 堆排序

### 1、构建大根堆

无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。

一个更高效的方法是**从右至左进行下沉操作**，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。

叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。 

### 2、交换

最大元素和当前堆中数组的最后一个元素交换位置，这样就固定了一个值，交换之后需要进行下沉操作维持堆的有序状态，将剩余的数重新构造成一个大根堆，重复这样的过程。

### 分析

N个节点的堆，堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。

堆排序是一种原地排序，没有利用额外的空间。

现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。



堆排序算法具体分析：

- 时间复杂度：O(nlogn)。

初始化建堆的时间复杂度为 O(n)，建完堆以后需要进行 n-1 次调整，一次调整的时间复杂度为 O(logn)，那么 n−1 次调整即需要 O(nlogn) 的时间复杂度。因此，总时间复杂度为 O(n+nlog n)=O(nlog n)。

- 空间复杂度：O(1)。

只需要常数的空间存放若干变量。

````java
public class HeapSort {
	public static void heapSort(int[] arr) {
        //1、构建大顶堆
        int len = arr.length;
        int m = len / 2 - 1;
        while (m>=0)
            sink(arr, m--, len-1);
        //2、固定一个值并将新值重新下沉
        while (len > 1) {
            swap(arr,0, len-1);
            sink(arr,0, --len);
        }
    }
    public static void sink(int[] arr, int i, int len) {
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int t;
        while (l < len) {
            t = arr[l] < arr[r] && r < len ? r:l;
            if (arr[i] > arr[t])
                t = i;
            if (i == t)
                break;
            swap(arr, t, i);
            i = t;
            l = 2 * i + 1;
            r = 2 * i + 2;
        }
    }
    public static void swap(int[] arr, int a, int b) {
        int t = arr[a];
        arr[a] = arr[b];
        arr[b] = t;
    }
}
````



## 参考：

https://www.javazhiyin.com/1200.html

https://blog.csdn.net/u010452388/article/details/81283998


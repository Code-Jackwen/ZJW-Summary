牛客：https://www.nowcoder.com/practice/7cd13986c79d4d3a8d928d490db5d707?tpId=117&&tqId=34969&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

题目转述：

和参考题目不一样的点是参考题目找最小值，本题找目标值，不一定最小，找到就返回索引，找不到返回-1。

且假设数组中不存在重复项。 





## 方法一：

我的思路：

先找到最小值，再根据最小值，也就是旋转点，再次二分查找目标值。



时间复杂度：两次二分查找，对数级别。



运行时间：20ms

占用内存：10436KB

````java
import java.util.*;

public class Solution {
    public int search(int[] A, int target) {
        //没翻转
        if (A[0] <= A[A.length - 1]) {
            return binarySearch(A, target, 0, A.length - 1);
        }
        // 找到翻转的点的下标
        int tem = findX(A);
        // 确定target在翻转点的右边还是左边
        if (target >= A[0]) {//3,1 找1   0 1
            return binarySearch(A, target, 0, tem);
        } else {
            return binarySearch(A, target, tem, A.length - 1);
        }
    }
    int binarySearch(int[] nums, int target, int l, int r) {
        int left = l, right = r;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                return mid;
            }
        }
        return -1;
    }
    int findX(int[] A) {
        int i = 0, j = A.length - 1;
        while (i < j) {
            int m = (i + j) / 2;
            if (A[m] > A[j]) i = m + 1;
            else if (A[m] < A[j]) j = m;
            else if (A[m] == A[j]) {
                int x = i;
                for (int k = i + 1; k < j; k++) {
                    if (A[k] < A[x]) x = k;
                }
                return x;
            }
        }
        return i;
    }
}
````



## 方法二：

不好想出。

````java
import java.util.*;

public class Solution {
    /**
     * 
     * @param A int	  整型一维数组 
     * @param target  int整型 
     * @return int    整型
     */
    public int search (int[] A, int target) {
        int left = 0, right = A.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (A[mid] == target) return mid;
            if (A[mid] >= A[left]) {
                // 左侧有序(含A[mid])
                if (A[mid] > target && A[left] <= target)
                    right = mid - 1;
                else
                    left = mid + 1;
            } else if (A[mid] < A[left]){
                // 右侧有序(含A[mid])
                if (A[mid] < target && A[right] >= target)
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
}
````





参考：

- [11. 旋转数组的最小数字](https://github.com/Code-Jackwen/ZJW-Summary/blob/main/notes-md/To offer/二分查找/11. 旋转数组的最小数字.md)


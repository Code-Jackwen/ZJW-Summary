牛客：https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=117&&tqId=34942&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking



转述：把链表m到n区间的节点顺序反转，要求时间On，空间O1



示例1

## 输入

```
{1,2,3,4,5},2,4
```

## 返回值

```
{1,4,3,2,5}
```



题目一样



力扣中等：[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

参考：

- [24. 反转链表](https://github.com/Code-Jackwen/ZJW-Summary/blob/main/notes-md/To offer/链表/24. 反转链表.md)



反转从位置 m 到 n 的链表。请使用**一趟扫描**完成反转。



说明:
1 ≤ m ≤ n ≤ 链表长度。



示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4

输出: 1->4->3->2->5->NULL





```cpp
//思路：head表示需要反转的头节点，pre表示需要反转头节点的前驱节点
//我们需要反转n-m次，我们将head的next节点移动到需要反转链表部分的首部，需要反转链表部分剩余节点依旧保持相对顺序即可
//比如1->2->3->4->5,m=1,n=5
//第一次反转：1(head) 2(next) 3 4 5 反转为 2 1 3 4 5
//第二次反转：2 1(head) 3(next) 4 5 反转为 3 2 1 4 5
//第三次发转：3 2 1(head) 4(next) 5 反转为 4 3 2 1 5
//第四次反转：4 3 2 1(head) 5(next) 反转为 5 4 3 2 1
```





时间On，最差情况下遍历On次。

空间O1

```java
public class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        //1->2->3->4->5	,[2,4]
        while (m > 1) {
            pre = pre.next;
            m--;//1
            n--;//3
        }
        //循环两次，定义cur为了下边好理解。
        ListNode cur = head = pre.next;
        while (n > 1) {
            ListNode next = cur.next;//next临时记录下3。下一轮next被赋值为4。
            cur.next = cur.next.next;//把3给删除了,2直接指向4，链表变为：1245。并顺带更新了cur.next的值。
            next.next = pre.next;//3指向了2，链接完毕。和下边这行顺序不能变。
            pre.next = next;//1指向了3，链表变为：13245。并顺带更新了pre.next的值。
            n--;
        }
        //14325
        return dummy.next;
    }
}
```


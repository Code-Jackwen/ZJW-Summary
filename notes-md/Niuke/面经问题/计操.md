## 内核态和用户态

内核态和用户态也可以说是内核空间和用户空间。

内核态：

 一种**特殊的软件程序**，特殊在哪儿呢？**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。 

内核态的cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以切换程序。

用户态：

所有用户程序都是运行在用户态的，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。例如： **用户态想要申请一块20K大小的动态内存** ，例如：例如从硬盘读取数据, 或者从键盘获取输入等。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。** 

用户态的cpu只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。



**为什么要有用户态和内核态？**

**限制不同的程序之间的访问能力,** 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络。



##### 用户态与内核态的切换

 3种最主要方式 方式 

1、系统调用 

例如： **用户态想要申请一块20K大小的动态内存**，或者说从硬盘读取数据, 或者从键盘获取输入等。

2、异常 

如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。 

3、外围设备的中断 

当外设完成用户的请求时，会向CPU发送中断信号。 



其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。 



Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。  **给不同的操作给与不同的“权限”** ，解决操作冲突。



## 虚拟内存 

**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为内存有一个连续完整的地址空间。而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上。使用这种技术的系统使得大型程序的编写变得更容易，对真正内存。例如：对RAM的使用也更有效率。

原理：对虚拟内存的定义是基于对**地址空间的重定义**的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。

现代所有用于一般应用的[操作系统](https://zh.wikipedia.org/wiki/操作系统)都对普通的应用程序使用虚拟内存技术，例如文字处理软件，多媒体播放器等等。老一些的操作系统，1980年代的[Windows](https://zh.wikipedia.org/wiki/Windows)，等等没有的。


 Java 中实现线程有三种方式： 1、1. 继承 Thread 类 public class Thread extends Object implements Runnable 定义 Thread 类的子类，并重写 Thread 类的 run () 方法，创建子类对象（即线程对象），调用线程对象的 start () 方法来启动该线程。 2. 实现 Runnable 接口 public interface Runnable 定义 Runnable 接口的实现类，并重写该接口的 run () 方法，该 run () 方法同样是该线程的执行体。创建该 Runnable 实现类的实例，并将此实例作为 Thread 的 target（即构造函数中的参数）来创建 Thread 对象（该 Thread 对象才是真正的线程对象，只是该 Threa 3. 使用 Callable 和 Future 创建 Callable 接口的实现类，并实现 call () 方法，该方法有返回值；创建 Callable 实现类的实例，使用 FutureTask 来包装 Callable 对象，并且也封装了 call () 方法的返回值；使用 FutureTask 作为 Thread 类的 target 创建并启动线程；调用 FutureTask 对象的 get () 方法返回子线程执行结束后的返回值。 如何实现多线程： 首先是继承 Thread 类并重写 run（）方法 package com.csu.multiThread; 

 public class MultiThreadExtendsThread extends Thread { String name; public MultiThreadExtendsThread (String name) { this.name = name; } public void run () { for (int i=0;i&lt;5;i++) { System.out.println (name+&quot; 运行：&quot;+i); } } public static void main (String [] args) { MultiThreadExtendsThread thread1 = new MultiThreadExtendsThread (&quot;A&quot;); MultiThreadExtendsThread thread2 = new MultiThreadExtendsThread (&quot;B&quot;); thread1.start (); thread2.start (); } } 二是实现 Runnable 接口，然后重写 run () 方法， package com.csu.multiThread; <br /> public class MultiThreadImplRunnable implements Runnable { String name; public MultiThreadImplRunnable (String name) { this.name = name; } @Override public void run () { for (int i=0;i&lt;5;i++) { System.out.println (name+&quot; 运行：&quot;+i); } } <br /> <br /> public static void main (String [] args) { MultiThreadExtendsThread thread1 = new MultiThreadExtendsThread (&quot;A&quot;); MultiThreadExtendsThread thread2 = new MultiThreadExtendsThread (&quot;B&quot;); new Thread (thread1).start (); new Thread (thread2).start (); <br /> } } 线程安全的实现： 最基本的：synchronized 关键字。这个方法是最常用的，它通过互斥的方式保证同步。我们知道 java 中有几个操作是可以保证原子性的，其中 lock/unlock 就是一对。虽然 java 没有提供这两个字节码的接口，但是我们可以通过 monitorenter/monitorexit，而 synchronized 会在块的前后调用两个字节码指令。同时 synchronize 对于同一条线程来说是可重入的；其次它也是阻塞的。我们知道 java 线程是映射到操作系统上的，而且是混用的内核态线程和用户态线程（N:M），而将线程从阻塞 / 唤醒，需要将线程从用户态转换到内核态，这样会消耗太亮的资源，所以 synchronize 是一个重量级锁 另外一种和 synchronize 类似的方法：ReentrantLock。它们两个的区别：（1）synchronize 是隐式的，只要块内的代码执行完，就会释放当前的锁；而后者需要显式的调用 unlock () 方法手动释放，所以经常搭配 try/finally 方法（忘记在 finally 中 unlock 是非常危险的） （2）后者可以选择等待中断 —— 即在当前持有锁线程长期不释放锁的情况下，正在等待的线程可以选择放弃等待选择处理其他的事情。 （3） 后者可以选择公平锁（虽然默认是非公平的，因为公平锁的吞吐量很受影响）即先来后到，按申请的顺序获得锁。 （4）可以绑定多个条件 前面提到的两种方式都是通过互斥来达到同步的目的，这其实是悲观锁的一种。下面介绍的是乐观锁，基于冲突检测的并发策略，不需要将线程挂起，因此又被成为非阻塞同步。 典型：CAS（Compare And Swap），通过 Unsafe 类提供。有三个操作数，内存位置、旧的预期值、和新的值；当且仅当内存地址 V 符合预期值 A 时，执行将值更新为新的预期值 B。 存在的问题：“ABA” 情况，即原值为 A，但在检测之前发生了改变，变成了 B，同时也在检测时变回了 A；即不能保证这个值没有被其他线程更改过。 接下来是无同步方案： 可重入代码（纯代码）：是一种无同步方案，在执行的任何时候去中断，转而执行其他的代码；在重新返回代码后，不会出现任何的错误。可重入性 -&gt; 线程安全，充分不必要条件。即可重入性的代码都是线程安全的，但反之不一定。简单判断原则：一个方法的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果。 线程本地存储：即利用 ThreadLocal 类；每个 Thread 类中都有一个变量 ThreadLocalMap，默认是为 null 的。它将为每一个线程创立一个该变量的副本。这样线程之间就不存在数据征用的问题了。适用情况：（1）数据库的 Connection 连接 （2）WEB 中的 “一个请求对应一个服务器线程”，在知乎上看到一个回答，解释的蛮清晰的。（3）Spring 中创建的默认模式是 Singleton 单例 （4）“生产者 - 消费者问题” ThreadLocal 就是变量在不同线程上的副本，不同线程不共享，所以对变量改动时就不需要考虑线程间同步的问题了 ThreadLocal 在 web 应用开发中是一种很常见的技巧，当 web 端采用无状态写法时（比如 stateless session bean 和 spring 默认的 singleton），就可以考虑把一些变量放在 ThreadLocal 中 举个简单例子，以理解意思为主：你有两个方法 A 和 B 都要用到变量 userId，又不想传来传去，一个很自然的想法就是把 userId 设为成员变量，但是在无状态时，这样做就很可能有问题，因为多个 request 在同时使用同一个 instance，userId 在不同 request 下值是不一样的，就会出现逻辑错误 < br /> 但由于同一个 request 下一般都是处于同一个线程，如果放在 ThreadLocal 的话，这个变量就被各个方法共享了，而又不影响其他 request，这种情况下，你可以简单把它理解为是一种没有副作用的成员变量 (作者：卡斯帕尔) 线程栈线程的每个方法被执行的时候，都会同时创建一个帧（Frame）用于存储本地变量表、操作栈、动态链接、方法出入口等信息。每一个方法的调用至完成，就意味着一个帧在 VM 栈中的入栈至出栈的过程。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果 VM 栈可以动态扩展（VM Spec 中允许固定长度的 VM 栈），当扩展时无法申请到足够内存则抛出 OutOfMemoryError 异常。 